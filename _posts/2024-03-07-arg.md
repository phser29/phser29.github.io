---
layout: single
title: "알고리즘"
categories: java
tag: other
toc: true
--- 

# 시간 복잡도

## 시간 복잡도의 정의

- 알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말함

- 빅-오메가: 최선일 떄의 연산 횟수를 나타낸 표기법
- 빅-세타: 보통일 때의 연산 횟수를 나타낸 표기법
- 빅-오: 최악일 때의 연산 횟수를 나타낸 표기법 -> 코테에선 항상 시간복잡도를 최악일 때를 염두해두고 해야함

```
public class timeComplexityExample1 {
  public static void main(String[] args) {
    //1~100 사이 값 랜덤 
    int findNumber = (int)(Math.random() * 100);
    for(int i=0; i<100; i++) {
      if(i == findNumber) {
        System.out.println(i);
        break;
      }
    }
  }
}
```

연산 횟수 = 알고리즘 시간 복잡도 X 데이터의 크기
시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출

# 디버깅

## 디버깅 하는 법
- 코드에서 디버깅하고자 하는 줄에 중단점을 설정하고 IDE의 디버깅 기능을 실행해 진행

1. 코드에서 디버깅하고자 하는 줄에 중단점을 설정 이 때 중단점은 여러 개 설정 가능
2. IDE의 디버깅 기능을 실행하면 코드를 1줄씩 실행하거나 다음 중단점까지 실행할 수 있으며
이 과정에서 추적할 변수값도 지정할 수 있다.
3. 변수값 이외에도 원하는 수식을 입력해 논리 오류를 파악할 수 있다.

## 실수가 많이 나오는 오류

1. 변수 초기화 오류
2. 반복문에서 인덱스 범위 지정 오류
3. 잘못된 변수 사용 오류
4. 자료형 범위 오류

```
public class 디버깅 {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int testcase = sc.nextInt();
    int answer = 0;
    int A[] = new int[100001];
    int S[] = new int[100001];
    for(int i=1; i<10000; i++) { //반복범위 잘못지정
      A[i] = (int) (Math.random() * Integer.MAX_VALUE);
      S[i] = S[i - 1] + A[i];
    }
    
    for(int t=1; t<testcase; t++) {
      int query = sc.nextInt();
      for(int i=0; i<query; i++) {
        int start = sc.nextInt();
        int end = sc.nextInt();
        answer += S[end] = S[start-1]; //반복적으로 더해짐
        System.out.println(testcase+" "+answer); // 잘못 입력 T 출력해야함
      }
    }
  }
}
```

## 배열과 리스트

- 배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조 
  1. 인덱스를 사용하여 값에 바로 접근할 수 있다.
  2. 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다.
  3. 배열의 크기는 선언할 때 지정할 수 있으며, 한 번 선언하면 크기를 늘리거나 줄일 수 있다.
  4. 구조가 간단하므로 코딩 테스트에서 많이 사용한다.

- 리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
  1. 인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다. 접근 속도가 느리다.
  2. 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산 속도가 빠르다.
  3. 선언할 때 크기를 별도로 지정하지 않아도 된다.
  4. 포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡하다.

## 구간의 합

- 구간 합은 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘

- 합 배열 S 정의
  - S[i] = A[0] + A[1] + A[2] + _ + A[i-1] + A[i]

## 스택과 큐

- 스택은 삽입과 삭제 연산이 후입선출(LIFO)로 이뤄지는 지료구조
- 깊이 우선 탐색, 백트레킹에 효과적임 후입선출 자체가 재귀 함수 원리와 비슷함
  - top : 삽입과 삭제가 일어나는 위치를 뜻한다.
  - push : top 위치에 현재 있는 데이터를 삽입하는 연산
  - pop : top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
  - peek : top 위치에 현재 있는 데이터를 단순 확인하는 연산

- 큐는 삽입과 삭제 연산이 선입선출로 이뤄지는 자료구조
- 너비 우선 탐색에서 자주 사용
  - rear: 큐에서 가장 끝 데이터를 가리키는 영역
  - front: 큐에서 가장 앞의 데이터를 가리키는 영역
  - add: rear 부분에 새로운 데이터를 삽입하는 연산
  - poll: front 부분에 있는 데이터를 삭제하고 확인하는 연산
  - peek: 큐의 맨앞에 있는 데이터를 확인할 때 사용하는 연산

## 버블정렬

- 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식
- 시간 복잡도 O(n2) 다른 알고리즘보다 느림

- 버블 정렬 과정
  1. 비교 연산이 필요한 루프 범위를 설정
  2. 인접한 데이터 값을 비교
  3. swap 조건에 부합하면 swap 연산을 수행
  4. 루프 범위가 끝날 때까지 2~3을 반복
  5. 정렬 영역을 설정 다음 루프를 실행할 때는 이 영역을 제외
  6. 비교 대상이 없을 때까지 1~5를 반복

- 만약 특정한 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면 그 영역 뒤에 있는 데이터가 모두 정렬됐다는 뜻이므로 프로세스를 종료

## 선택정렬

- 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 수능로 찾아가며 선택하는 방법
- 선택 정렬 과정
  1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
  2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
  3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬부분의 범위를 축소한다.
  4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복

## 삽입정렬

- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
- 선택 데이터를 현재 정렬된 데이터 벙위 내에서 적절한 위치에 삽입하는 것이 삽입 정렬의 핵심
- 삽입 정렬 수행방식
  1. 현재 index에 있는 데이터 값을 선택
  2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색
  3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행
  4. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복
- 적적할 삽입 위치를 탐색하는 부분에서 이진 탐색등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있음

## 병합정렬

- 분할 정복 방식을 하용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘 시간 복잡도(O(nlogn))



