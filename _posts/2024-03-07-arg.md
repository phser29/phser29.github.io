---
layout: single
title: "알고리즘"
categories: java
tag: arg
toc: true
--- 

# 시간 복잡도

## 시간 복잡도의 정의

알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말함

- 빅-오메가: 최선일 떄의 연산 횟수를 나타낸 표기법
- 빅-세타: 보통일 때의 연산 횟수를 나타낸 표기법
- 빅-오: 최악일 때의 연산 횟수를 나타낸 표기법 -> 코테에선 항상 시간복잡도를 최악일 때를 염두해두고 해야함

```
public class timeComplexityExample1 {
  public static void main(String[] args) {
    //1~100 사이 값 랜덤 
    int findNumber = (int)(Math.random() * 100);
    for(int i=0; i<100; i++) {
      if(i == findNumber) {
        System.out.println(i);
        break;
      }
    }
  }
}
```

연산 횟수 = 알고리즘 시간 복잡도 X 데이터의 크기
시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출

# 디버깅

## 디버깅 하는 법
코드에서 디버깅하고자 하는 줄에 중단점을 설정하고 IDE의 디버깅 기능을 실행해 진행

1. 코드에서 디버깅하고자 하는 줄에 중단점을 설정 이 때 중단점은 여러 개 설정 가능
2. IDE의 디버깅 기능을 실행하면 코드를 1줄씩 실행하거나 다음 중단점까지 실행할 수 있으며
이 과정에서 추적할 변수값도 지정할 수 있다.
3. 변수값 이외에도 원하는 수식을 입력해 논리 오류를 파악할 수 있다.

## 실수가 많이 나오는 오류
  1. 변수 초기화 오류
  2. 반복문에서 인덱스 범위 지정 오류 찾기
  3. 

  ```
  public class 디버깅 {
    public static void main(String[] args) {
      Scanner sc = new Scanner(System.in);
      int testcase = sc.nextInt();
      int answer = 0;

      int A[] = new int[100001];
      int S[] = new int[100001];

      for(int i=1; i<10000; i++) { //반복범위 잘못지정
        A[i] = (int) (Math.random() * Integer.MAX_VALUE);
        S[i] = S[i - 1] + A[i];
      }
      
      for(int t=1; t<testcase; t++) {
        int query = sc.nextInt();
        for(int i=0; i<query; i++) {
          int start = sc.nextInt();
          int end = sc.nextInt();
          answer += S[end] = S[start-1]; //반복적으로 더해짐
          System.out.println(testcase+" "+answer);
        }
      }
    }
  }
  ```

  