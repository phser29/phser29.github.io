---
layout: single
title: "react"
categories: javaScript
tag: react
toc: true
---

# 리액트

- vue, angular은 양방향 데이터 바인딩 리액트는 단방향

- 리액트 프로젝트 생성

> npx create-react-app 프로젝트이름&버전

> npm start

- 타입스크립트 컴파일러 설치

> npm i -g typescript ts-node

> npx create-react-app 프로젝트 이름 --template typescript

- 프리티어 설정

```
npm install -g -E prettier

.prettierrc.js
module.exports = {
  bracketSpacing: false,
  jsxBracketSameLine: true,
  singleQuote: true,
  trailingComma: 'none',
  arrowParens: 'avoid',
semi: false,
printWidth: 90
};

```

## jsx

- javaScript + XML
- React.createElement 호출 코드를 간결하게 하려고 고안한 것으로, 자바스크립트 언어를 확장하는 방식으로 구현
- jsx 구문을 작성할 때는 XML 구약을 엄격하게 준수 ex) < />
- {} -> xml 문법에는 없는 기능이 필요
- return 키워드 없이 값을 반환하는 구문 -> ESNext JS 표현식
- xml요소는 부모 없이 존재 못함

## key와 children 속성

- 모든 리액트 컴포넌트는 key와 ref라는 속성을 포함 children도 있음

## typescript type과 interface의 차이

### interface
- extends 키워드를 이용해서 확장할 수 있다.

### type
- & 기호를 이용해서 확장할 수 있다.

```
interface Person {
  name: string;
  age: number;
}

interface Student extends Person { // 확장(상속)
  school: string;
}

const jieun: Student = {
  name: 'jieun',
  age: 27,
  school: 'HY'
}

type Person = {
  name: string,
  age: number
}

type Student = Person & { // 확장(상속)
  school: string
}

const jieun: Student = {
  name: 'jieun',
  age: 27,
  school: 'HY'
}
```

## 컴포넌트

- 스몰토크에서 유래
- 화면 UI를 처리하는 클래스를 의미
- 모델-뷰-컨트롤러 설계지침에 따라 설계
- 카멜 표기법으로 작성

```
// 클래스 단위 컴포넌트

import React, { Component } from 'react';
import ClassComponent from './component/ClassComponent';

class App extends Component {
  render() {
    return (
      <div>
        <ul>
          <ClassComponent href="http://www.google.com" text="go to Google" />
        </ul>
      </div>
    );
  }
  
}

export default App;
```

## Props
- TypeScript에서는 타입을 지정할 수 있음
- FC : Function Component 줄임말로 React + TypeScript 조합으로 개발할 때 사용하는 타입

```
import React, { Component } from 'react';

// JS와는 다르게 타입을 직접 만들어서 사용
// interface로도 할수 있음

// 클래스 방식
export type ClassComponentProps = {
  href: string,
  text: string
}

class ClassComponent extends Component<ClassComponentProps> {
  render(): React.ReactNode {
    
    return (
      <div>
        <li>
          <a href={href}>
            <p>{text}</p>
          </a>
        </li>
      </div>
    );  
  }
};

// 함수 방식
const ClassComponent:FC<ClassComponentProps> = (props) => {
  render(): React.ReactNode {

    const {href, text} = this.props;
    
    return (
      <div>
        <li>
          <a href={href}>
            <p>{text}</p>
          </a>
        </li>
      </div>
    );  
  }
};
```

- export default ClassComponent;

## 속성

- 클래스의 맴버 변수
- 값이 수시로 바뀌는 가변
- 값이 안바뀌는 불변
- 상태 프로그래밍 속성 재랜더링

### 함수형 컴포넌트

- 상용구 코드가 없기 때문에 컴포넌트를 좀 더 간결하게 구현
- 타입스크립트에서 타입은 자바스크립트로 컴파일할 때만 필요한 정보

```
// function 키워드 방식
export default function App() {
  return <h1>function component</h1>
}

// 화살표 방식
const App = () => {
  return <h1>function component</h1>
}
```

### key 속성

- 같은 이름의 컴포넌트가 여러 개일 때 이들을 구분하려고 리액트 프레임워크가 만든 속성

```
function App() {
  const texts = ['hello', 'world'].map((text, index) => <p key={index}>{text}</p>);

  return <div>{texts}</div>;
}
```

- 18버전 부터는 children속성 제거 PropsWithChildren타입으로 대체

```
import type {FC, PropsWithChildren} from 'react'

export type PProps = {}
const P: FC<PropsWithChildren<PProps>> = (props: any) => {
  return <p {...props} />
}
export default P

//P 컴포넌트에 children 속성 추가
import React from 'react';
import P from './P';

function App() {
  const texts = ['hello', 'world'].map((text, index) => <P key={index} children={text} />)
  return <div children={texts} />
}

export default App;
```

- 이벤트 : 텍스트 입력과 같은 사용자 행위가 일어날 때 이벤트가 발생했다라고 표현

### Event 타입
  1. type: 이벤트 이름으로 대소 문자를 구분하지 않음
  2. isTrusted: 이벤트가 웹 브라우저에서 발생한 것인지(true), 프로그래밍으로 발생한 것인지(false)를 판단
  3. target: 이벤트가 처음 발생한 HTML 요소
  4. currentTarget: 이벤트의 현재 대상, 즉 이벤트 버블링 중에서 이벤트가 현재 위치한 객체
  5. bubbles: 이벤트가 DOM을 타고 버블링될지 여부를 결정합니다.

- HTMLElement는 최상위 EventTarget 타입을 시작으로 Node, Element와 같은 타입을 상속
- 옵셔널 체이닝 : ?. -> getElmentById가 null을 호출하면 이벤트 발생 안함
- 변수 뒤에 ? 붙으면 생략가능한 선택 매개 변수가 됨

```
document.getElementById('root')?.addEventListener('click', (e: Event) => {
  const {isTrusted, target, bubbles} = e
  console.log('mouse click occurs.', isTrusted, target, bubbles)
})
document.getElementById('root')?.addEventListener('click', (e: Event) => {
  const {isTrusted, target, bubbles} = e
  console.log('mouse click also occurs.', isTrusted, target, bubbles)
})

export default function EventListener() {
  return <div>EventListener</div>
}
```

- synthetic : 모든 종류의 이벤트를 종합

- SyntheticEvent : BaseSyntheticEvent 상속

- stopPropagation : 가까운 부모에서 먼 부모 쪽으로 이벤트가 버블링되며 전달되는 것을 멈추는 것 이를 이벤트 캡쳐링

- 사용자의 입력이 텍스트면 change가 발생 change이벤트는 onChange 이벤트 속성으로 얻음

```
export default function OnChange() {
  const onChangeValue = (e: ChangeEvent<HTMLInputElement>) => {
    e.stopPropagation()
    e.preventDefault()
    console.log('onChangeValue', e.target.value)
  }
  const onChangeChecked = (e: ChangeEvent<HTMLInputElement>) => {
    e.stopPropagation()
    console.log('onChangeChecked', e.target.checked)
  }
  const onChangeFiles = (e: ChangeEvent<HTMLInputElement>) => {
    e.stopPropagation()
    console.log('onChangeFiles', e.target.files)
  }
  // prettier-ignore
  return (
    <div>
      <p>OnChange</p>
      <input type="text" onChange={onChangeValue}
        placeholder="type some text" defaultValue="Hello"/>
      <input type="checkbox" onChange={onChangeChecked} defaultChecked/>
      <input type="file" onChange={onChangeFiles} multiple accept="images/*" />
    </div>
  )
}
```

- dispatchEvent : boolean

```
interface BaseSyntheticEvent<E = object, C = any, T = any> {
  nativeEvent: E;
  currentTarget: C;
  target: T;
  preventDefault(): void;
  stopPropagation(): void;
}
```

- 이벤트 버블링 : 자식 요소에서 발생한 이벤트가 가까운 부모 요소에서 가장 먼 부모 요소까지 께속 전달되는 현상
- multiple : 기본이 false 1개만 선택 ture일 때는 여러개 선택가능
- accept : "images/#" -> 이미지 파일로 변환, "text/plain" -> 텍스트 파일로 제한
- const files: FileList : null = e.target.files;

```
export default function FileDrop() {
  const onDragOver = (e: DragEvent) => e.preventDefault()

  const onDrop = (e: DragEvent) => {
    e.preventDefault() // 웹 브라우저의 새로운 창에 드롭한 이미지가 나타나는 것을 방지
    const files = e.dataTransfer.files
    if (files) {
      for (let i = 0; i < files.length; i++) {
        const file: File | null = files.item(i) //혹은 file = files[i];
        console.log(`file[${i}]: `, file)
      }
    }
  }

  return (
    <div>
      <p>FileDrop</p>
      <div onDrop={onDrop} onDragOver={onDragOver}>
        <h1>Drop image files over Me</h1>
      </div>
    </div>
  )
}
```

### draggable

> < draggable>Drag Me</>

- dragenter : 드래그한 요소나 텍스트 블록을 적합한 드롭 대상 위에 올라갔을 때 발생
- dragstart : 사용자가 요소나 텍스트 블록을 드래그하기 시작했을 때 발생
- drag : 요소나 텍스트 블록을 드래그할 때 발생
- dragover : 요소나 텍스트 블록을 적합한 드롭 대상 위로 지나갈 때 발생
- dragleave : 드래그하는 요소나 텍스트 블록이 적합한 드롭 대상에서 벗어났을 때 발생
- dragend : 드래그를 끝냈을 때 발생
- drop : 요소나 텍스트 블록을 적합한 드롭 대상에 드롭했을 때 발생합니다.

# styled-components

> npm i styled-components @types/styled-components

```
import styled from 'styled-components';

const FooterBox = styled.div`
    position: absolute;
    right: 0;
    bottom: 0;
    left: 0;
    padding: 1rem;
    background-color: ${(p2) => (p2.theme === "basic" ? "skyblue" : "yellow")};
    text-align: center;
  `;
```

- app.tsx

```
import { useState } from "react";
import CountryList from "./CountryList";
import styles from "./styles";
import module from './App.module.css';
import { Footer } from "./component/Footer";
import { BasicButton, ItalicButton, UnderLineButton, WhiteUnderlineButton } from "./component/Buttons";

export type CountryType = {
  no: number;
  country: string; 
  visited: boolean;
}

function App() {
  const [theme, setTheme] = useState<string>("basic");

  const [msg, setMsg] = useState<string>("");

  return (
    <div className="container">
      <h2 className={module.test}>Hello {msg}!</h2>
      <hr style={styles.dashStyle} />
      {addResult(4, 3)}
      <CountryList countries={list} />
      <button onClick={onclick}>msg 추가</button>
      <button onClick={onList}>list 추가</button>

      <BasicButton>기본</BasicButton>
      <ItalicButton>이탤릭</ItalicButton>
      <UnderLineButton>언더라인</UnderLineButton>
      <WhiteUnderlineButton>화이트 언더라인</WhiteUnderlineButton>

      <Footer theme={theme} />
    </div>
  )
}

export default App
```

## 속성의 유효성 검증

- 컴포넌트에서 사용할 수 있는 속성은 무엇인지 확인
- 필수 속성은 무엇인지 확인
- 속성에 전달할 수 있는 값의 타입은 무엇인지 확인

### PropTypes

- 리액트가 지원하는 기능이며, 컴파일할 때가 아닌 실행 중에 속성에 대한 유효성 검증을 수행

> npm i prop-types

```
/* eslint-disable @typescript-eslint/no-unused-vars */
import React from 'react'
import PropTypes from 'prop-types'

interface CalcPropsTypes {
  x: number;
  y: number;
  oper: string;
}

export const Calc = (props: CalcPropsTypes) => {
  let result: number = 0;
  
  switch(props.oper) {
    case "+":
      result = props.x + props.y;
      break;
    case "*":
      result = props.x * props.y;
      break;
    default:
      result = 0;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const calcChecker = (props: any, propName: string, componentName: string) => {
    if(propName === 'oper') {
      if(props[propName] !== "+" && props[propName] !== "*") {
        return new Error(`${propName}속성의 값은 반드시 '+', '*'만 허용합니다(at ${componentName})`);
      }
    }
  }

  Calc.prototype = {
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired,
    oper: calcChecker
  };

  return (
    <>
      <h3>연산 방식: {props.oper}</h3>
      <hr />
      <div>
        {props.x} {props.oper} {props.y} = {result}
      </div>
    </>
  )
}
```

### 지정 가능한 유효성 검증 타입

- 단순 타입
  - PropTypes.array : 배열 타입
  - PropTypes.bool: true/false의 불리언 타입
  - PropTypes.func: 속성을 이용해 함수와 메서드를 전달하는 함수 타입
  - PropTypes.number: 숫자 타입
  - PropTypes.object: 객체 타입
  - PropTypes.string: 문자열 타입

- 복잡한 유효성 검증 타입
  - PropTypes.instanceOf(Customer)
  - PropTypes.oneOf(['+', '*']) : []에 포함된 값 중의 하나인지를 검증
  - PropTypes.oneOfType([PropTypes.number, PropTypes.string]): []에 포함된 타입의 값인지를 검증
  - PropTypes.arrayOf(PropTypes.object): 객체의 배열인지를 검증

```
const calcChecker = (props: any, propName: string, componentName: string) => {
    if(propName === "oper") {
      if(props[propName] !== "+" && props[propName] !== "*") {
        return new Error(`${propName}속성의 값은 반드시 '+', '*'만 허용합니다(at ${componentName})`);
      }
    }
    if(propName === "y") {
      let y = props[propName];
      if(y > 100 || y < 0 || y % 2 !== 0) {
        return new Error(`${propName}속성은 값은 0 이상 100 이하의 짝수만 허용.(at ${componentName})`)
      }
    }
  }

  Calc.prototype = {
    x: PropTypes.number.isRequired,
    y: calcChecker,
    oper: calcChecker
  };
```

# 리액트 이벤트

- 이벤트 위임

- 주의할 점
  - 이벤트 핸들러를 지정할 때는 카멜 표기법을 사용합니다. HTML에서는 onclick처럼 모두 소문자를 사용하지만 리액트 이벤트에서는 onclick으로 표기
  - 이벤트를 함수 또는 메서드와 연결할 때는 다음과 같이 {} 보간법을 사용 이때 리액트 이벤트는 HTML DOM 이벤처럼 문자열로 함수 호출 구문을 작성할 없다. 대신에 익명 함수를 {} 내부에 작성하여 호출 구문을 작성

  ```
  //함수 또는 메서드 호출
  <button onClick={func}>ok</button>
  //익명 함수 호출
  <button onClick={() => alert('hello')}>ok</button>
  ```

  - DOM 요소가 아닌 컴포넌트에 이벤트를 설정할 수 없습니다. 즉, 다음과 같은 코드는 에러가 발생합니다.

  ```
  <MyComponent onCLick={() => alert('hello')} name={'홍길동'} /> 
  ```

## 이벤트 적용 방법

- 첫째는 이벤트 핸들러 함수를 정의하여 {} 보간법을 이용해 외부 함수를 바인딩함
- 이름없는 함수도 바인딩 가능

```
const eventHandler = () => {...}

//jsx 내부에서 외부 함수 바인딩
<input type="text" ... onChange={eventHandler}>

//jsx 내부에서 익명 함수 바인딩
<button onClick={() => {...}}>버튼</button>
```

- 둘쨰는 이벤트 핸들러 함수의 첫 번째 인자를 이용해 이벤트 아규먼트 값을 이용

```
const eventHandler = (e : ChangeEvent<HTMLInputElement>) => {
  setValue(e.target.vale);
}
```

# 제어 컴포넌트와 비제어 컴포넌트

## 제어 컴포넌트

- UI에서 입력 필드의 값이 상태나 속성에 의해 강하게 제어되는 컴포넌트 따라서 상태, 속성이 바뀌지 않는 한 입력값을 변경 못함
- 제어 컴포넌트에서 입력 필드의 값을 변경하려면 리액트의 이벤트 핸들러를 이용해 상태를 변경해야 함

```
import { useState } from "react"

function App2() {
  const [x, setX] = useState<number>(0);
  const [y, setY] = useState<number>(0);

  return (
    <>
      <h3>제어 컴포넌트</h3>
      X: <input type="text" value={x}/>
      <br/>
      Y: <input type="text" value={y}/>
      <br/>
      결과 : <span>{x + y}</span>
    </>
  )
}

export default App2
```

## 비제어 컴포넌트


